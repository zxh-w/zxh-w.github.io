<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zxh-w.github.io</id>
    <title>zxh</title>
    <updated>2024-03-03T11:03:49.862Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zxh-w.github.io"/>
    <link rel="self" href="https://zxh-w.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zxh-w.github.io/images/avatar.png</logo>
    <icon>https://zxh-w.github.io/favicon.ico</icon>
    <rights>All rights reserved 2024, zxh</rights>
    <entry>
        <title type="html"><![CDATA[爬虫基础库]]></title>
        <id>https://zxh-w.github.io/post/pa-chong-ji-chu-ku/</id>
        <link href="https://zxh-w.github.io/post/pa-chong-ji-chu-ku/">
        </link>
        <updated>2023-09-06T13:46:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="requests">requests</h1>
<h2 id="requests模块介绍">requests模块介绍</h2>
<blockquote>
<p>requests 文档：https://requests.readthedocs.io/projects/cn/zh_CN/latest/</p>
</blockquote>
<h3 id="requests模块的作用">requests模块的作用</h3>
<blockquote>
<p>发送http请求，获取响应数据</p>
</blockquote>
<h3 id="requests模块的安装">requests模块的安装</h3>
<p><code>pip install requests</code></p>
<h2 id="response响应对象">response响应对象</h2>
<p>有时候 <code>response.text</code>会出现好多乱码；这是因为编解码使用的字苻集不同早造成的；我们尝试使用下边的办法来决中文乱码问题：</p>
<ol>
<li><code>response.text</code>是<code>requests</code>模块按照<code>charset</code>模块推测出的编码字符集进行解码的结果</li>
<li>网络传输的字符串都是<code>bytes</code>类型的，所以<code>response.text=response.content.decode('推测出的编码字符集'）</code></li>
<li>我们可以在网页源码中搜索<code>charset</code>，尝试参考该编码字符集，注意存在不准确的情况</li>
</ol>
<h3 id="responsetext和responsecontent的区别">response.text和response.content的区别</h3>
<ul>
<li>
<p><code>response.text</code></p>
<p>类型：<code>str</code></p>
<p>解码类型：<code>requests</code>模块自动根据HTTP头部对响应的编码作出有根据的推测，推测的文本编码</p>
</li>
<li>
<p><code>response.content</code></p>
<p>类型：<code>bytes</code></p>
<p>解码类型：没有指定</p>
</li>
</ul>
<h3 id="通过对responsecontent进行decode解决中文乱码">通过对response.content进行decode,解决中文乱码</h3>
<ul>
<li><code>response.content.decode() #默认utf-8</code></li>
<li><code>response.content.decode('GBK')</code></li>
<li>常见的编码字符集
<ul>
<li>utf-8</li>
<li>gbk</li>
<li>gbk2312</li>
<li>ascii</li>
<li>iso-8859-1</li>
</ul>
</li>
</ul>
<h3 id="response响应对象的其它常用属性或方法">response响应对象的其它常用属性或方法</h3>
<blockquote>
<p><code>response = requests.get(url)</code>中<code>response</code>是发送请求获取的响应对象；response()响应对象中除了 text、content获取响应内容外还有属性或方法：</p>
</blockquote>
<ul>
<li><code>reponse.url</code> 响应的url;有时候响应的url和请求的url并不一致</li>
<li><code>response.status_code</code> 响应状态码</li>
<li><code>response.request.headers</code> 响应对应的请求头</li>
<li><code>response.headers</code> 响应头</li>
<li><code>response.request._cookies</code> 响应对应请求的cookie，返回cookieJar类型</li>
<li><code>response.cookies</code> 响应的cookie（经过了set-cookie动作；返回型cookieJar类型）</li>
<li><code>response.json</code>() 自动将<code>json</code>字符串类型的响应内容转挨为python对象(dict or list)</li>
</ul>
<h2 id="requestssession进行状态保持">requests.session进行状态保持</h2>
<blockquote>
<p>requests模块中的Session类能自动处理发送请求获取响应过程中产生的cookie，进而达到状态保持的目的。</p>
</blockquote>
<h3 id="作用及应用场景">作用及应用场景</h3>
<ul>
<li><code>requests.session</code>的作用
<ul>
<li>自动处理cookie，即下一次的请求会带上前一次的cookie</li>
</ul>
</li>
<li><code>requests.session</code>的应用场景
<ul>
<li>自动处理连续的多次请求过程中产生的cookie</li>
</ul>
</li>
</ul>
<h3 id="requestssession使用方法"><code>requests.session</code>使用方法</h3>
<blockquote>
<p>session实例在请求了一个网站后，对方服务器设置在本地的cookie会保存在session中，下一次再使用session请求对方服务器的时候，会带上前一次的cookie。</p>
</blockquote>
<pre><code class="language-python">session = requests.session()
response = session.get(url,headers,...)
response = session.post(url,data,...)
</code></pre>
<ul>
<li>session实例发送get或post请求的参数，与requests模块发送请求的参数完全一致</li>
</ul>
<h2 id="post数据来源">post数据来源</h2>
<ul>
<li>固定值：抓包比较后不变值</li>
<li>输入值：抓包比较后根据自身变化值</li>
<li>预设值-静态文件：需要提前从静态HTML中提取</li>
<li>预设值-发送请求：需要对指定地址发送请求</li>
<li>在客户端生成：分析JS，模拟生成数据</li>
</ul>
<h1 id="数据提取">数据提取</h1>
<h2 id="响应内容的分类">响应内容的分类</h2>
<ul>
<li>结构化的响应内容
<ul>
<li><code>json</code>字符串：可以使用<code>re</code>、<code>json</code>等模块来提取特定数据</li>
<li><code>xml</code>字符串：可以使用re、lxml等模块来提取特定数据</li>
</ul>
</li>
<li>非结构化响应内容
<ul>
<li>html字符串：可以使用用re、lxml等模块来提取特定内容</li>
</ul>
</li>
</ul>
<h2 id="xml与html的区别">xml与html的区别</h2>
<blockquote>
<p>xml是一种可扩展标记语言，样子和html很像，功能更专注于数据传输。</p>
</blockquote>
<table>
<thead>
<tr>
<th>数据格式</th>
<th>描述</th>
<th>设计目标</th>
</tr>
</thead>
<tbody>
<tr>
<td>XML</td>
<td>可扩展标记语言</td>
<td>被设计为传输和存储数据，其焦点是数据的内容</td>
</tr>
<tr>
<td>HTML</td>
<td>超文本标记语言</td>
<td>显示数据以及如何更好地显示数据</td>
</tr>
</tbody>
</table>
<h2 id="常用数据解析方法">常用数据解析方法</h2>
<figure data-type="image" tabindex="1"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230702073422947.png" alt="image-20230702073422947" loading="lazy"></figure>
<h2 id="jsonpath模块">jsonpath模块</h2>
<blockquote>
<p>如果有一个多层嵌套的复杂字典，想要根据key和下标来批量提取value，这是比较困难的。</p>
</blockquote>
<ul>
<li>jsonpath可以按照key对python字典进行批量数据提取</li>
<li>模块安装：<code>pip install jsonpath</code></li>
<li>使用方法：<code>ret = jsonpath(a_dict,'json语法规则字符串')</code></li>
</ul>
<h3 id="jsonpath语法规则">jsonpath语法规则</h3>
<table>
<thead>
<tr>
<th>JSONPath</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$</code></td>
<td>根节点</td>
</tr>
<tr>
<td><code>@</code></td>
<td>现行结点</td>
</tr>
<tr>
<td><code>.</code>or <code>[]</code></td>
<td>取子节点</td>
</tr>
<tr>
<td><code>..</code></td>
<td>不管位置，选择所有符合条件的结点</td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配所有元素结点</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>迭代器标识（可以在里面做简单的迭代操作，如数组下标、根据内容选值）</td>
</tr>
<tr>
<td><code>[,]</code></td>
<td>支持迭代器中做多选</td>
</tr>
<tr>
<td><code>?()</code></td>
<td>支持过滤操作</td>
</tr>
<tr>
<td><code>()</code></td>
<td>支持表达式计算</td>
</tr>
</tbody>
</table>
<h2 id="xpath和lxml模块">xpath和lxml模块</h2>
<ul>
<li>lxm模块可以利用XPath规则语法，来快速的定位HTML以ML文档中特定元紊以及获取节点信息（文本、内容、属性值）</li>
<li>XPath(XML Path Language)是一门在HTML\XML文档中查找倍息的语言，可用来在HTML\XML文档中对<strong>元素和属性进行遍历</strong>。
<ul>
<li>W3School官方文档：http://www.w3school.com/cn/xpath/index.asp</li>
</ul>
</li>
<li>提取xml、html中的数据需要lxml块xpath语法配合使用</li>
</ul>
<h3 id="xpath语法">xpath语法</h3>
<blockquote>
<p>每个html、xml的标签我们都称之为结点，其中最顶层的结点称为根节点。</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230702084404706.png" alt="image-20230702084404706" loading="lazy"></figure>
<ol>
<li>xpath使用路径表达式来选取XML文档中的节点或者节点集</li>
<li>这些路径和我们在常规的电脑文件系统中看到的表达式非常相似</li>
<li>使用chrome插件选择标签的时候，选中时，选择的标签会添加属性 <code>class=&quot;xh-highlight&quot;</code></li>
</ol>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>nodename</td>
<td>选中该元素</td>
</tr>
<tr>
<td>/</td>
<td>从根节点中选取、或者是元素和元素之间的过滤</td>
</tr>
<tr>
<td>//</td>
<td>从匹配选择的当前节点中选择文档中的节点，而不考虑它们的位置</td>
</tr>
<tr>
<td>.</td>
<td>选取当前结点</td>
</tr>
<tr>
<td>..</td>
<td>选取当前结点的父节点</td>
</tr>
<tr>
<td>@</td>
<td>选取属性</td>
</tr>
<tr>
<td>text()</td>
<td>选取文本</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gin和Web]]></title>
        <id>https://zxh-w.github.io/post/gin-he-web/</id>
        <link href="https://zxh-w.github.io/post/gin-he-web/">
        </link>
        <updated>2023-09-06T13:45:02.000Z</updated>
        <content type="html"><![CDATA[<h3 id="软件开发流程">软件开发流程</h3>
<figure data-type="image" tabindex="1"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/14135927173.png" alt="软件定制开发流程- 湖北国菱计算机科技有限公司-湖北国联计算机科技有限公司-荆州网站建设-荆州软件开发-政府网站建设公司" loading="lazy"></figure>
<h3 id="简化开发流程">简化开发流程</h3>
<ul>
<li>需求分析</li>
<li>设计（概要，详细）</li>
<li>开发&amp;&amp;调试</li>
<li>测试-上线</li>
</ul>
<h3 id="gin-web开发分层">Gin Web开发分层</h3>
<figure data-type="image" tabindex="2"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230801184827409.png" alt="image-20230801184827409" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP通信]]></title>
        <id>https://zxh-w.github.io/post/tcp-tong-xin/</id>
        <link href="https://zxh-w.github.io/post/tcp-tong-xin/">
        </link>
        <updated>2023-09-06T13:39:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="非阻塞io">非阻塞IO</h2>
<h3 id="网络分层">网络分层</h3>
<blockquote>
<p>RESP是Redis的通信协议。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230803122354420.png" alt="image-20230803122354420" loading="lazy"></figure>
<h3 id="tcp通信过程">TCP通信过程</h3>
<figure data-type="image" tabindex="2"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/78805a221a988e7.png" alt="img" loading="lazy"></figure>
<h3 id="socket">Socket</h3>
<ul>
<li>
<p>很多系统都提供Socket作为TCP网络连接的对象</p>
</li>
<li>
<p>Linux —&gt; Internet domain socket —&gt; <code>SOCK_STREAM</code></p>
</li>
<li>
<p>Linux中Socket以&quot;文件描述符&quot; FD作为标识</p>
</li>
<li>
<p>通信过程：</p>
<figure data-type="image" tabindex="3"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230803125644938.png" alt="image-20230803125644938" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230803130319200.png" alt="image-20230803130319200" loading="lazy"></figure>
</li>
</ul>
<h3 id="io模型">IO模型</h3>
<ul>
<li>IO模型是指同时操作Socket的方案</li>
<li>阻塞</li>
<li>非阻塞</li>
<li>多路复用、</li>
</ul>
<h4 id="阻塞io模型">阻塞IO模型</h4>
<figure data-type="image" tabindex="5"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230803132801639.png" alt="image-20230803132801639" loading="lazy"></figure>
<ul>
<li>同步读写Socket时，线程陷入内核态</li>
<li>进程阻塞挂起不消耗CPU资源，及时响应每个操作</li>
<li>当读写成功后，切换回用户态，继续执行</li>
<li>优点：开发难度小，代码简单</li>
<li>缺点：因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大</li>
</ul>
<h4 id="非阻塞io模型">非阻塞IO模型</h4>
<figure data-type="image" tabindex="6"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230803133418920.png" alt="image-20230803133418920" loading="lazy"></figure>
<ul>
<li>如果暂时无法收发数据，会返回错误</li>
<li>应用回不断轮询，直到Socket可以读写</li>
<li>优点：不会陷入内核态，自由度高</li>
<li>缺点：需要自旋轮询</li>
</ul>
<h4 id="多路复用linux-epoll">多路复用—Linux epoll</h4>
<blockquote>
<p>多个的进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select， select会监听所有注册进来的IO；</p>
<p>如果select监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回；</p>
<p>而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。</p>
</blockquote>
<figure data-type="image" tabindex="7"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230803133750072.png" alt="image-20230803133750072" loading="lazy"></figure>
<ul>
<li>注册多个Socket事件</li>
<li>调用epool，当有事件发生，返回</li>
<li>优点：提供里事件列表，不需要轮询各个Socket</li>
<li>缺点：开发难度大，逻辑复杂</li>
</ul>
<h3 id="go抽象epoll">Go抽象epoll</h3>
<blockquote>
<p>结合阻塞模型和多路复用：</p>
<ul>
<li>在底层使用操作系统的多路复用IO</li>
<li>在协程层次使用阻塞模型</li>
<li>阻塞协程时，协程休眠</li>
</ul>
</blockquote>
<figure data-type="image" tabindex="8"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230803134430288.png" alt="image-20230803134430288" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230803134854919.png" alt="image-20230803134854919" loading="lazy"></figure>
<ul>
<li>
<p>epoll抽象层是为了统一各个操作系统对多路复用器的实现</p>
<ul>
<li>
<p>Linux：Epoll</p>
</li>
<li>
<p>Windows：IOCP</p>
</li>
<li>
<p>Mac：Kqueue</p>
</li>
</ul>
</li>
<li>
<p>各个系统的多路复用都有以下功能</p>
<ul>
<li>新建多路复用器 <code>epoll_create()</code></li>
<li>往多路复用器里插入需要监听的事件： <code>epoll_ctl()</code></li>
<li>查询什么事件发生了 <code>epoll_wait()</code></li>
</ul>
</li>
<li>
<p>Go Network Poller(<strong>多路复用抽象层</strong>)</p>
<ul>
<li>
<p><code>epoll_create()</code> ——&gt; <code>netpollinit()</code></p>
<ul>
<li>
<p>新建Epoll</p>
</li>
<li>
<p>新建一个pipe管道用于中断Epoll</p>
</li>
<li>
<p>将“管道有数据到达”事件注册在Epoll中</p>
</li>
</ul>
</li>
<li>
<p><code>epoll_ctl()</code> ——&gt; <code>netpollopen()</code></p>
<ul>
<li>传入一个<code>Socket</code>的FD和<code>pollDesc</code>指针</li>
<li>pollDesc指针是Socket相关详细信息</li>
<li>pollDesc中记录了哪个协程休眠在等待此Socket</li>
<li>将Socket可读、可写、断开事件注册到Epoll</li>
</ul>
</li>
<li>
<p><code>epoll_wait()</code> ——&gt; <code>netpoll()</code></p>
<ul>
<li>调用epoll_wait()，查询那些事件发生了</li>
<li>根据Socket相关的pollDesc信息，返回哪些协程可以唤醒</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="network-poller">Network Poller</h3>
<figure data-type="image" tabindex="10"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230803145554863.png" alt="image-20230803145554863" loading="lazy"></figure>
<ul>
<li>
<p>Network Poller初始化</p>
<ul>
<li><code>poll_runtime_pollServerInit()</code></li>
<li>使用原子操作保证只初始化一次</li>
<li>调用<code>netpollinit()</code></li>
</ul>
</li>
<li>
<p><code>pollCache</code>与 <code>pollDesc</code></p>
<ul>
<li>
<p><code>pollCache</code>：一个带锁的链表头</p>
</li>
<li>
<p><code>pollDesc</code>：链表的成员</p>
</li>
<li>
<p><code>pollDesc</code>是runtime包对Socket在Go中的详细描述</p>
</li>
<li>
<p><code>rg</code>，<code>wg</code>：1, 或 2,或等待的协程G的地址</p>
<figure data-type="image" tabindex="11"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230803143053384.png" alt="image-20230803143053384" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p>收发数据</p>
<ul>
<li>协程需要收发数据时，Socket已经可以读写
<ul>
<li>runtime循环调用<code>netpoll()</code>方法（<code>g0协程</code>）</li>
<li>发现Socket可读写时，给对应的<code>rg</code>或者<code>wg</code>置为<code>pdReady(1）</code></li>
<li>协程想要调用Socket时，协程调用<code>poll_runtime_poIIWait()</code></li>
<li>判断<code>rg</code>或者<code>wg</code>已经置为<code>pdReady(1)</code>,返回0</li>
</ul>
</li>
<li>协程需要收发数据时，Socket暂时无法读写
<ul>
<li>runtime循环调用<code>netpoll()</code>方法（<code>g0协程</code>）</li>
<li>协程调用<code>poll_runtime_poIIWait()</code></li>
<li>发现对应的<code>rg</code>或者<code>wg</code>为0</li>
<li>给对应的<code>rg</code>或者<code>wg</code>置为协程地址</li>
<li>休眠等待</li>
<li>runtime循环调用netpoll()方法（<code>g0</code>协程）</li>
<li>发现Socket可读写时，给对应的查看对应的<code>rg</code>或者<code>wg</code></li>
<li>若为协程地址，返回协程地址</li>
<li>调度器开始调度对应协程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="socket抽象">Socket抽象</h3>
<ul>
<li>
<p>net包</p>
<ul>
<li>net包是go原生的网络包</li>
<li>net包实现了TCP、UDP、UTTP等操作</li>
</ul>
</li>
<li>
<p><code>net.Listen()</code></p>
<ul>
<li>新建Socket()，并执行bind操作</li>
<li>新建一个FD（net包对Socket的详情描述）</li>
<li>返回一个TCPListener</li>
<li>将TCPListener的FD信息加入监听</li>
</ul>
</li>
<li>
<p><code>TCPListener.Accept()</code></p>
<ul>
<li>直接调用Socket的accept()</li>
<li>如果失败，休眠等待新的连接</li>
<li>将新的Socket包装为TCPConn变量返回</li>
<li>将TCPConn的FD信息加入监听</li>
</ul>
</li>
<li>
<p><code>TCPConn.Read()/Write()</code></p>
<ul>
<li>
<p>直接调用Socket原生读写方法</p>
</li>
<li>
<p>如果失败，休眠等待可读/可写</p>
</li>
<li>
<p>被唤醒后调用系统Socket</p>
</li>
<li>
<p>net包抽象了TCP网络操作</p>
</li>
<li>
<p>使用net.Listen()得到TCPListener(LISTEN状态的Socket)</p>
</li>
<li>
<p>使用TCPListener.Accept()得到TCPConn(ESTABLESHED)</p>
</li>
<li>
<p>TCPConn.Read()/Write()进行读写Socket的操作</p>
</li>
<li>
<p>NetworkPoller作为上述功能的底层支撑</p>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[爬虫中的去重处理]]></title>
        <id>https://zxh-w.github.io/post/pa-chong-zhong-de-qu-chong-chu-li/</id>
        <link href="https://zxh-w.github.io/post/pa-chong-zhong-de-qu-chong-chu-li/">
        </link>
        <updated>2023-09-06T13:37:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="爬虫中的去重处理">爬虫中的去重处理</h2>
<h3 id="去重应用场景以及基本原理">去重应用场景以及基本原理</h3>
<h4 id="什么业务需要使用去重">什么业务需要使用去重</h4>
<ul>
<li>防止发出重复的请求</li>
<li>防止存储重复的数据</li>
</ul>
<h4 id="去重实现的基本原理">去重实现的基本原理</h4>
<p>根据给定的判断依据和给定的去重容器，将原始数据逐一进行判断，判断去重容器中是否有该数据。如果没有那就把该数据对应的判断依</p>
<p>据添加去重容器中，同时标记该数据是<strong>不重复数据</strong>；如果有就不添加，同时标记该数据是<strong>重复数据</strong>。</p>
<ul>
<li>判断依据（<strong>原始数据</strong>、<strong>原始数据特征值</strong>）</li>
<li>去重容器（存储判断数据）</li>
</ul>
<h4 id="根据原始数据进行去重判断">根据原始数据进行去重判断</h4>
<figure data-type="image" tabindex="1"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230710182031264.png" alt="image-20230710182031264" loading="lazy"></figure>
<h4 id="根据原始数据特征值进行去重判断">根据原始数据特征值进行去重判断</h4>
<figure data-type="image" tabindex="2"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230710182206514.png" alt="image-20230710182206514" loading="lazy"></figure>
<h4 id="临时去重容器和持久化去重容器">临时去重容器和持久化去重容器</h4>
<ul>
<li>临时去重容器指如利用list、set等编程语言的数据结构存储去重数据，一旦程序关闭或重启，去重容器中的数据就被回收了
<ul>
<li>持久化去重容器是指如利用Redis、MySQL等数据库存储去重数据</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230710182829961.png" alt="image-20230710182829961" loading="lazy"></figure>
<h3 id="基于信息摘要算法的去重">基于信息摘要算法的去重</h3>
<h4 id="信息摘要hash算法的介绍">信息摘要HASH算法的介绍</h4>
<ul>
<li>信息摘要hash算法指可以将任意长度的文本、字节数据，通过一个算法得到一个固定长度的文本。如MD5（128位）、SHA1（160位）等。
<ul>
<li>特征：只要源文本不同，计算得到的结果，必然不同（摘要）。</li>
<li>摘要：摘要算法主要用于比对信息源是否一致，因为只要源发生变化，得到的摘要必然不同；而且通常结果要比源短很多，所以称为&quot;摘要&quot;。</li>
</ul>
</li>
<li>正因此，利用信息摘要算法能大大降低去重容器的存储空间使用率，并提高判断速度，且由扌其强唯一性的特征几乎不存在误判。</li>
<li>注意：
<ul>
<li>hash算法得出的结果其实本质上就是一串数值，如md5的128位指的是二进制的长度，十六进制的长度是32位。一个十六进制等于四个二进制。</li>
</ul>
</li>
</ul>
<h4 id="信息摘要hash算法去重方案实现">信息摘要HASH算法去重方案实现</h4>
<ul>
<li>普通内存版本</li>
<li>Redis持久化版本</li>
<li>MySQL持久化版本</li>
</ul>
<h3 id="基于simhash算法的去重">基于simhash算法的去重</h3>
<h4 id="应用场景">应用场景</h4>
<ul>
<li>simhash算法是一种局部敏感哈希算法，能实现<strong>相似</strong>文本内容的去重。</li>
<li>与信息摘要算法的区别：
<ul>
<li>信息摘要算法：如果原始内容只相差一个字节，所产生的签名也很可能差别很大。</li>
<li>Simhash算法：如果原始内容只相差一个字节，所产生的签名差别非常小。</li>
</ul>
</li>
<li>Simhash值比对：通过两者的simhash值的二进制位的差异来表示原始文本内容的差异。差异个数又被称为海明距离。</li>
<li>注意：
<ul>
<li>Simhash对长文本500字+比较适用，短文本可能偏差较大</li>
<li>在google的论文给出的数据中，64位simhash值，在海明距离为3的情况下，可认为两篇文档是相似的或者是重复的。当然这个值只是参考值，针对自己的应用可能有不同的测试<br>
取值。</li>
</ul>
</li>
</ul>
<h4 id="使用方法">使用方法</h4>
<p>https://leons.im/posts/a-python-implementation-of-simhash-algorithm/</p>
<h3 id="布隆过滤器原理与实现">布隆过滤器原理与实现</h3>
<h4 id="原理">原理</h4>
<figure data-type="image" tabindex="4"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230716080203569.png" alt="image-20230716080203569" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230716090620557.png" alt="image-20230716090620557" loading="lazy"></figure>
<h4 id="布隆过滤器实现redis版">布隆过滤器实现(Redis版)</h4>
<pre><code class="language-python"># 布隆过滤器 redis 版本实现
import hashlib
import redis


# 1.多个hash函数的实现和求值
# 2.hash表实现和实现对应的映射和判断


class MultipleHash(object):
    &quot;&quot;&quot;根据提供的原始数据，和预定义的多个salt,生成多个hash函数值 &quot;&quot;&quot;

    def __int__(self, salts, hash_func_name=&quot;md5&quot;):
        if len(salts) &lt; 3:
            raise Exception(&quot;请提供至少3个salt!&quot;)
        self.salts = salts
        self.hash_func = getattr(hashlib, hash_func_name)

    def _safe_data(self, data):
        &quot;&quot;&quot;
        :param data:原始数据
        :return: 二进制类型的字符串数据
        &quot;&quot;&quot;
        if isinstance(data, bytes):
            return data
        elif isinstance(data, str):
            return data.encode()
        else:
            raise Exception(&quot;请提供一个字符串！&quot;)

    def get_hash_values(self, data):
        hash_values = []
        for salt in self.salts:
            hash_obj = self.hash_func()
            hash_obj.update(self._safe_data(data))
            hash_obj.update(self._safe_data(salt))
            value = hash_obj.hexdigest()
            hash_values.append(int(value, 16))
        return hash_values

class BloomFilter(object):

    def __int__(self, salts, redis_host=&quot;localhost&quot;, redis_post=6379, redis_db=0, redis_key=&quot;domain&quot;):
        self.redis_host = redis_host
        self.redis_port = redis_post
        self.redis_db = redis_db
        self.redis_key = redis_key
        self.client = self._get_redis_conn()
        self.multiple_hash = MultipleHash(salts)

    def _get_redis_conn(self):
        &quot;&quot;&quot;
        :return:返回一个redis连接对象
        &quot;&quot;&quot;
        poll = redis.ConnectionPool(self.redis_host, self.redis_port, self.redis_db, &quot;664548&quot;)
        client = redis.StrictRedis(connection_pool=poll)
        return client

    def _get_offset(self,hash_value):
        return hash_value % (2**8 * 2**20 * 2**3)

    def save(self, data):
        hash_values = self.multiple_hash.get_hash_values(data)
        for hash_value in hash_values:
            offset = self._get_offset(hash_value)
            self.client.setbit(self.redis_key,offset,1)
        return True

    def is_exits(self, data):
        hash_values = self.multiple_hash.get_hash_values(data)
        for hash_value in hash_values:
            offset = self._get_offset(hash_value)
            v = self.client.getbit(self.redis_key, offset)
            if v == 0:
                return False
        return True
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows常用命令]]></title>
        <id>https://zxh-w.github.io/post/windows-chang-yong-ming-ling/</id>
        <link href="https://zxh-w.github.io/post/windows-chang-yong-ming-ling/">
        </link>
        <updated>2023-09-06T13:17:30.000Z</updated>
        <content type="html"><![CDATA[<p><code>ifconfig /all</code> 获取获取域名、IP地址、DHCP服务器、网关、MAC地址、主机名<br>
<code>net time /domain</code> 查看域名、时间<br>
<code>net view /domain</code> 查看域内所有共享<br>
<code>net view ip</code> 查看对方局域网内开启了哪些共享<br>
<code>net config workstation</code> 查看域名、机器名等<br>
<code>net user 用户名 密码 /add</code> 建立用户<br>
<code>net user 用户名 /del</code> 删除用户<br>
<code>net user guest /active:yes</code> 激活guest账户<br>
<code>net user</code> 查看账户<br>
<code>net user 账户名</code> 查看指定账户信息<br>
<code>net user /domain</code> 查看域内有哪些用户，Windows NT Workstation 计算机上可用，由此可以此判断用户是否是域成员。<br>
<code>net user 用户名 /domain</code> 查看账户信息<br>
<code>net group /domain</code> 查看域中的组<br>
<code>net group &quot;domain admins&quot; /domain</code> 查看当前域的管理用户<br>
<code>query user</code> 查看当前在线的用户<br>
<code>net localgroup</code> 查看所有的本地组<br>
<code>net localgroup administrators</code> 查看administrators组中有哪些用户<br>
<code>net localgroup administrators</code> 用户名 /add 把用户添加到管理员组中<br>
<code>net start</code> 查看开启服务<br>
<code>net start</code> 服务名 开启某服务<br>
<code>net stop</code> 服务名 停止某服务<br>
<code>net share</code> 查看本地开启的共享<br>
<code>net share ipc$</code> 开启<code>ipc$</code>共享<br>
<code>net share ipc$ /del</code> 删除<code>ipc$</code>共享<br>
<code>net share c$ /del</code> 删除C：共享<br>
<code>\\192.168.0.108\c</code> 访问默认共享c盘<br>
<code>dsquery server</code> 查看所有域控制器<br>
<code>dsquery subnet</code> 查看域内内子网<br>
<code>dsquery group</code> 查看域内工作组<br>
<code>dsquery site</code> 查看域内站点<br>
<code>netstat -a</code> 查看开启了哪些端口,常用netstat -an<br>
<code>netstat -n</code> 查看端口的网络连接情况，常用netstat -an<br>
<code>netstat -v</code> 查看正在进行的工作<br>
<code>netstat -p</code> 协议名 例：netstat -p tcq/ip 查看某协议使用情况（查看tcp/ip协议使用情况）<br>
<code>netstat -s</code> 查看正在使用的所有协议使用情况<br>
<code>nbtstat -A ip</code> 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名（03前的为用户名）-注意：参数-A要大写<br>
<code>reg save hklm\sam sam.hive</code> 导出用户组信息、权限配置<br>
<code>reg save hklm\system system.hive</code> 导出SYSKEY<br>
<code>net use \\目标IP\ipc$ 密码 /u:用户名</code> 连接目标机器<br>
<code>at \\目标IP 21:31 c:\server.exe</code> 在某个时间启动某个应用<br>
<code>wmic /node:&quot;目标IP&quot; /password:&quot;123456&quot; /user:&quot;admin&quot;</code> 连接目标机器<br>
<code>psexec.exe \\目标IP -u username -p password -s cmd</code> 在目标机器上执行cmd<br>
<code>finger username @host</code> 查看最近有哪些用户登陆<br>
<code>route print</code> 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface<br>
<code>arp</code> 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。<br>
<code>arp -a</code> 将显示出全部信息<br>
<code>nslookup</code> IP地址侦测器<br>
<code>tasklist</code> 查看当前进程<br>
<code>taskkill /pid PID数</code> 终止指定PID进程<br>
<code>whoami</code> 查看当前用户及权限<br>
<code>systeminfo</code> 查看计算机信息（版本，位数，补丁情况）<br>
<code>ver</code> 查看计算机操作系统版本<br>
<code>tasklist /svc</code> 查看当前计算机进程情况<br>
<code>netstat -ano</code> 查看当前计算机进程情况<br>
<code>wmic product &gt; ins.txt</code> 查看安装软件以及版本路径等信息，重定向到ins.txt</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[云原生]]></title>
        <id>https://zxh-w.github.io/post/yun-yuan-sheng/</id>
        <link href="https://zxh-w.github.io/post/yun-yuan-sheng/">
        </link>
        <updated>2023-09-06T13:13:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="云原生概述">云原生概述</h3>
<h4 id="定义">定义</h4>
<p><a href="https://www.cncf.io/about/who-we-are/">云原生基金会</a></p>
<p>云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。</p>
<p>这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。</p>
<p>云原生计算基金会（CNCF）致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术。我们通过将最前沿的模式民主化，让这些创新为大众所用。</p>
<h4 id="生态"><a href="https://www.cncf.io/projects/">生态</a></h4>
<h3 id="容器">容器</h3>
<h4 id="容器的调用链路">容器的调用链路</h4>
<figure data-type="image" tabindex="1"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-container-way.png" alt="image-20230828224333615" loading="lazy"></figure>
<h3 id="不可变基础设施">不可变基础设施</h3>
<blockquote>
<p>传统的基础设施管理方式中，管理员需要手动修改和维护服务器(Server)和应用程序(Application)的配置。而不可变基础设施的思想是将整个基础设施定义为代码，通过自动化的方式进行创建、部署和管理。当需要更新或修改基础设施时，不是直接在现有实例上进行修改，而是通过创建新的实例来替代旧的实例，确保每次更新都是在一个全新的环境中进行。</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230828230047409.png" alt="image-20230828230047409" loading="lazy"></figure>
<ul>
<li>手动配置和维护：传统的基础设施管理方式需要管理员手动配置和维护服务器和应用程序的各种设置，包括安装、更新、修改配置等，容易出现人为错误和配置差异。</li>
<li>可靠性和稳定性：由于人为的操作和配置差异，传统基础设施管理方式容易引入错误和故障，导致系统的不稳定和不可靠。</li>
<li>难以扩展和缩减：传统基础设施管理方式需要手动进行扩展和缩减，需要管理员手动配置和部署新的服务器或移除旧的服务器，操作复杂、耗时且容易出错。</li>
<li>难以追踪和管理：传统基础设施管理方式下，很难准确追踪和管理服务器和应用程序的状态和配置变化，容易导致管理混乱和不可控。</li>
<li>安全性风险：传统基础设施管理方式下，管理员需要直接在服务器上进行配置和修改，容易引入潜在的安全漏洞和风险。</li>
<li>难以复原和回滚：由于传统基础设施管理方式下的修改是直接在现有实例上进行的，当出现问题时，很难快速复原和回滚到之前的状态。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230828230110809.png" alt="image-20230828230110809" loading="lazy"></figure>
<ul>
<li>可靠性：由于不可变基础设施是通过创建全新实例来更新，可以避免由于修改配置而引入的错误和故障。</li>
<li>可重现性：通过将基础设施定义为代码，可以确保每次创建的实例都是一致的，减少了因为手动配置而引入的差异。</li>
<li>安全性：由于不可变基础设施不允许直接修改，减少了潜在的安全漏洞和风险。</li>
<li>可扩展性：通过自动化的方式创建和管理基础设施，可以更容易地进行扩展和缩减。</li>
</ul>
<h3 id="声明式api">声明式API</h3>
<blockquote>
<p>通过一行命令执行多个命令的集合</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[边缘计算]]></title>
        <id>https://zxh-w.github.io/post/bian-yuan-ji-suan/</id>
        <link href="https://zxh-w.github.io/post/bian-yuan-ji-suan/">
        </link>
        <updated>2023-09-06T13:13:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="万物互联面临的挑战">万物互联面临的挑战</h3>
<figure data-type="image" tabindex="1"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230827222108697.png" alt="image-20230827222108697" loading="lazy"></figure>
<h4 id="海量设备">海量设备</h4>
<p>每秒钟大概有100多台物联网设备接入互联网，在物联网的设备快速增长的背景下将会有海量设备需要管理，将会面临海量设备的管理问题</p>
<h4 id="带宽瓶颈">带宽瓶颈</h4>
<p>由于设备较多，数据的交互频率也会大幅提高，那么就会随之带宽瓶颈问题</p>
<h4 id="计算可靠">计算可靠</h4>
<p>海量设备下云端进行统一管理由于云端计算任务太大计算的可靠性难以得到保证</p>
<h4 id="安全性">安全性</h4>
<p>由于设备产生的数据通过网络进行传输，也将面临数据安全性问题</p>
<h4 id="数据实时">数据实时</h4>
<p>由于带宽不够，产生数据延迟云端计算资源不够的情况下，再向云端发起请求就要很久才能等到响应</p>
<h3 id="边缘计算解决方案">边缘计算解决方案</h3>
<figure data-type="image" tabindex="2"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230827222253998.png" alt="image-20230827222253998" loading="lazy"></figure>
<h4 id="云原生特性的边缘计算">云原生特性的边缘计算</h4>
<figure data-type="image" tabindex="3"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230827222437820.png" alt="image-20230827222437820" loading="lazy"></figure>
<h4 id="诞生背景">诞生背景</h4>
<figure data-type="image" tabindex="4"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230827223842961.png" alt="image-20230827223842961" loading="lazy"></figure>
<ul>
<li>
<p>物联网：物联网设备地理位置非常分散，响应时间、海量设备管理、数据安全性难以保证。</p>
</li>
<li>
<p>人工智能：人工智能应用需要大量的逻辑运算资源，当对运算速度有更高的要求时候，数据传输带来的性能消耗问题，将会让AI应用的响应延迟。</p>
</li>
<li>
<p>解决方案：</p>
<blockquote>
<p>边缘计算，让计算更贴近数据的源头！从而解决海量设备管理、数据传输等问题</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230827224218390.png" alt="image-20230827224218390" loading="lazy"></figure>
</li>
</ul>
<h4 id="应用案例">应用案例</h4>
<figure data-type="image" tabindex="6"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230827224720433.png" alt="image-20230827224720433" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230827225348396.png" alt="image-20230827225348396" loading="lazy"></figure>
<h4 id="物联网">物联网</h4>
<p>原始物联网架构图</p>
<figure data-type="image" tabindex="8"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230827225505888.png" alt="image-20230827225505888" loading="lazy"></figure>
<p>加入边缘计算后的物联网架构图‘</p>
<figure data-type="image" tabindex="9"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230827225650998.png" alt="image-20230827225650998" loading="lazy"></figure>
<h4 id="云原生">云原生</h4>
<ol>
<li>
<p>标准环境：基于标准的API环境开发和移植应用程序</p>
<blockquote>
<p>容器化能够解决边缘计算产品的运行环境问题，但是随着生产环境的增多，也暴露出很多不足之处。</p>
</blockquote>
<figure data-type="image" tabindex="10"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230827230249689.png" alt="image-20230827230249689" loading="lazy"></figure>
<p><strong>不足之处</strong>：</p>
<ul>
<li><strong>单机限制</strong>：缺乏多机通信网络，限制边缘总算力规模</li>
<li><strong>编排限制</strong>：缺乏多实例和扩展主机的连接能力，限制了对复杂业务的描述能力</li>
<li><strong>更新限制</strong>：需要安装业务之外的应用才能对容器进行更新</li>
<li><strong>管理限制</strong>：边缘应用的定义和管理模式与应用分离，限制了业务的敏捷性</li>
</ul>
</li>
<li>
<p>统一编排：由单一的控制面系统管理云和边缘的应用</p>
</li>
<li>
<p>可伸缩性：一套架构能够支持不同性能、不同规模的设施</p>
</li>
<li>
<p>去中心化：模糊边缘和中心的边界，实现应用和数据的全局分布式协作</p>
</li>
</ol>
<h4 id="开源社区">开源社区</h4>
<ul>
<li>
<p><strong>KubeEdge</strong></p>
<figure data-type="image" tabindex="11"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-kubeEdge-system.png" alt="image-20230827231101983" loading="lazy"></figure>
</li>
<li>
<p><strong>OpenYurt</strong></p>
<figure data-type="image" tabindex="12"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-OpenYurt-system3.png" alt="image-20230827231248813" loading="lazy"></figure>
</li>
<li>
<p><strong>Baetyl</strong></p>
<figure data-type="image" tabindex="13"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-Baetyl.png" alt="image-20230827231552306" loading="lazy"></figure>
</li>
</ul>
<figure data-type="image" tabindex="14"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-Baetyl-system.png" alt="image-20230827231744501" loading="lazy"></figure>
<ul>
<li>相同点：
<ul>
<li>底层基于<code>Kubernetes</code>，将边缘节点抽象为Node结点</li>
<li>边缘应用以容器（<code>K8S Pod</code>）方式运行</li>
<li>通过数据缓存和同步保证离线算</li>
<li>云端管理，边缘计算，云边协同</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web框架概览]]></title>
        <id>https://zxh-w.github.io/post/web-kuang-jia-gai-lan/</id>
        <link href="https://zxh-w.github.io/post/web-kuang-jia-gai-lan/">
        </link>
        <updated>2023-09-06T13:11:15.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>对于Web框架的印象大概就是：处理HTTP请求的。好在因为我们造的轮子其实都不是从0到1，所以我们可以通过参考其它web框来设计自己的框架。</p>
</blockquote>
<h2 id="beego">Beego</h2>
<h3 id="controller抽象">Controller抽象</h3>
<p>Beego是基于MVC(Model-View-Controller)的，所以它定义了一个核心接口 <code>ControllerInterface</code>.</p>
<figure data-type="image" tabindex="1"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230730194521173.png" alt="image-20230730194521173" loading="lazy"></figure>
<p><code>ControllerInterface</code>定义了一个控制器必须要解决什么问题。同时<code>ControllerInterface</code>的默认实现<code>Controller</code>提供了实现自定义控制器的各种辅助方法，所以在Beego里面，一般都是组合<code>Controller</code>来实现自己的<code>Controller</code>.</p>
<h3 id="httpserver和controllerregister">HttpServer和ControllerRegister</h3>
<p><code>ControllerInterface</code>可以看作核心接口，因为它直接体现了Beego的设计初衷：MVC模式。同时它也是用户的核心接入点。</p>
<p>但是如果从功能特性上来说，HttpServer和ControllerRegister才是核心。</p>
<ul>
<li><code>HttpServer</code>：代表一个“服务器”，大多数时候它就是一个进程。</li>
<li><code>ControllerRegister</code>：真正干活的人。注册路由，路由匹配和执行业务代码都是透过它来完成的。</li>
</ul>
<h3 id="context抽象">Context抽象</h3>
<p>用户操作请求和响应是通过<code>Ctx</code>来达成的。它代表的是整个请求执行过程的上下文。进一步，Beego又将Context细分了几个部分：</p>
<ul>
<li>Input：定义了很多和处理请求有关的方法</li>
<li>Output：定义了很多和响应有关的方法</li>
<li>Response：对<code>http.ResdponseWriter</code>的二次封装</li>
</ul>
<h3 id="核心抽象">核心抽象</h3>
<ul>
<li><code>ControllerRegister</code>最为基础，它解决了路由注册和路由匹配这个基础问题。</li>
<li><code>Context</code>和<code>Controller</code>为用户提供了丰富API,用于辅助构建系统。</li>
<li><code>HttpServer</code>作为服务器抽象，用于管理应用生命周期和资源隔离单位。</li>
</ul>
<h2 id="gin">Gin</h2>
<h3 id="iroutes接口">IRoutes接口</h3>
<blockquote>
<p>Gin没有controller的抽象。即MVC应该是用户组织web项目的模式，而不是中间件设计者要考虑的。</p>
</blockquote>
<ul>
<li>核心接口IRoutes：提供的是注册路由的抽象。它的实现类Engine类似于ControllerRegister。</li>
<li>Use方法提供里用户接入自定义逻辑的能力，这个一般情况下也被看作插件机制。</li>
<li>额外提供了静态文件的接口。</li>
</ul>
<h3 id="engine实现">Engine实现</h3>
<p>Engine可以看作是Beego中HttpServer和ControllerRegister的合体。</p>
<ul>
<li>实现了路由树功能，提供注册和匹配路由的功能</li>
<li>它本身可以作为一个Handler传递到http包，用于启动服务器。</li>
</ul>
<p>Engine的路由树功能本质上是依赖于methodTree的。</p>
<h3 id="methodtrees和methodtree">methodTrees和methodTree</h3>
<p>methodTree才是真正的路由树。</p>
<p>Gin定义了methodTrees，它实际上代表的是森林，即每一个HTTP方法都对应一棵树。</p>
<h3 id="handlerfunc和handlerschain">HandlerFunc和HandlersChain</h3>
<ul>
<li>HandlerFunc定义了核心抽象——处理逻辑。</li>
<li>在默认情况下，它代表了注册路由的业务代码。</li>
<li>HandlersChain则是构造了责任链模式。</li>
</ul>
<h3 id="context抽象-2">Context抽象</h3>
<p>context也是代表了执行的上下文，提供了丰富的API:</p>
<ul>
<li>处理请求的API,代表的是以Get和Bind为前缀的方法</li>
<li>处理响应的API,例如返回JSON或者XML响应的方法</li>
<li>渲染页面，如HTML方法</li>
</ul>
<h2 id="iris">Iris</h2>
<h3 id="application">Application</h3>
<p>Application是lris的核心抽象，它代表的是&quot;应用&quot;。实际上这个语义更加接近Beego的HttpServer和Gin的Engine。它提供了：</p>
<ul>
<li>生命周期控制功能，如Shutdown等方法</li>
<li>注册路由的API</li>
</ul>
<h3 id="路由相关">路由相关</h3>
<p>lris的设计非常复杂。在Beego和Gin里面能够明显看到路由树的痕迹，但是在lris里面就很难看出来。<br>
和处理路由相关的三个抽象：<br>
<code>Route</code>：直接代表了已经注册的路由。在Beego和Gin里面，对应的是路由树的节点<br>
<code>APlBuilder</code>：创建Route的Builder模式，Party也是它创建的<br>
<code>repository</code>：存储了所有的Routes,有点接近Gin的methodTrees的概念</p>
<h3 id="context抽象-3">Context抽象</h3>
<ul>
<li>Context也是代表上下文。</li>
<li>Context本身也是提供了各种处理请求和响应的方法。</li>
<li>基本上和Beego和Gin的Context没啥区别。</li>
<li>比较有特色的是它的Context支持请求级别的添加Handler,即<code>AddHandler</code>方法。</li>
</ul>
<h2 id="echo">Echo</h2>
<h3 id="echo-2">Echo</h3>
<p>Echo是它内部的一个结构体，类似于Beego的HttpServer和Gin的Engine:</p>
<ul>
<li>
<p>暴露了注册路由的方法，但是它并不是路由树的载体</p>
</li>
<li>
<p>生命周期管理：如Shutdown和Start等方法</p>
</li>
</ul>
<p>在Echo里面有两个相似的字段：</p>
<ul>
<li>router:这其实就是代表路由树</li>
<li>routers：这代表的是根据Host来进行分组组织，可以看做是近似于<code>namespace</code>之类的概念，既是一种组织方式，也是一种隔离机制</li>
</ul>
<h3 id="route和node">Route和node</h3>
<p>Router代表的就是路由树，node代表的是路由树上的节点。</p>
<p>node里面有一个很有意思的设计：<code>staticChildren</code>、<code>paramChild</code>和<code>anyChild</code>利用这种设计可以轻松实现路由优先级和路由冲突检测。</p>
<p>它里面还有一个子echo,维护的是使用Route的Echo实例。这种设计形态在别的地方也能见到，比如说在<code>sql.Tx</code>里面维持了一个<code>sql.DB</code>的实例。</p>
<h3 id="context">Context</h3>
<p>一个大而全的接口，定义了处理请求和响应的各种方法。</p>
<p>和Beego、Gin、lris的Context没有什么区别。</p>
<h2 id="框架对比">框架对比</h2>
<figure data-type="image" tabindex="2"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230730205915660.png" alt="image-20230730205915660" loading="lazy"></figure>
<h2 id="web框架面试题">Web框架面试题</h2>
<p>从整体上来面的话，比较高频率的问题：</p>
<ul>
<li>web框架拿来做什么？处理HTTP请求，为用户提供便捷API,为用户提供无侵入式的插件机制，提供如上传下载等默认功能</li>
<li>为什么都已经有了http包，还要开发web框架？高级路由功能、封装HTTP上下文以提供简单APls封装server以提供生命周期控制、设计插件机制以提供无侵入式解决方案</li>
<li>web框架的核心？路由树、上下文Context、Server</li>
</ul>
<h2 id="server">Server</h2>
<p>从前面框架对比来看,对于一个Web框架来说,我们首先要有一个整体代表服务器的抽象，也就是Server。</p>
<p>Server从特性上来说，至少要提供三部分功能：</p>
<ul>
<li><strong>生命周期控制</strong>：即启动、关闭。如果在后期，我们还要考虑增加生命周期回调特性</li>
<li><strong>路由注册接口</strong>：提供路由注册功能</li>
<li><strong>作为http包到web框架的桥梁</strong></li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230730211112825.png" alt="image-20230730211112825" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker概览]]></title>
        <id>https://zxh-w.github.io/post/docker-gai-lan/</id>
        <link href="https://zxh-w.github.io/post/docker-gai-lan/">
        </link>
        <updated>2023-05-29T13:17:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="docker简介">Docker简介</h3>
<h4 id="什么是docker">什么是Docker</h4>
<p>Docker是开发，运行和部署应用程序的开放平台。</p>
<ul>
<li>开发人员能利用Docker开发和运行应用程序。</li>
<li>运维人员能利用Docker部署和管理应用程序。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230529203137105.png" alt="image-20230529203137105" loading="lazy"></figure>
<h4 id="为什么使用docker">为什么使用Docker</h4>
<ul>
<li>
<p>Docker使您能够将应用程序与基础架构分开，以便您可以快速交付软件。</p>
</li>
<li>
<p>借助Docker，您可以像管理应用程序一样管理基础架构。</p>
</li>
<li>
<p>通过利用Docker的方法快速进行运输，测试和部署代码，可以明显缩短编写代码和在生产环境中运行代码之间的</p>
<p>延迟。</p>
<ul>
<li>开发人员在本地编写代码，可以使用Docker同事进行共享，实现协同工作；</li>
<li>使用Docker开发完成程序，可以直接对应用程序执行自动和手动测试；</li>
<li>当开发人员发现吴或BUG时，可以直接在开发环境中修复后，并迅速将它们重新部署到测试环境进行测试和验证；</li>
<li>利用Docker开发完成后，交付时，直接交付Docker，也就意味着交付完成。后续如果有提供修补程序或更新，需要推送到生成环境运行起来，也是一样的简单。</li>
</ul>
</li>
<li>
<p>Docker主要解决的问题．</p>
<ul>
<li>保证程序运行环境的一致性。</li>
<li>降低配置开发环境、生产环境的复杂度和成本。</li>
<li>实现程序的快速部署和分发。</li>
</ul>
</li>
</ul>
<h3 id="docker整体架构">Docker整体架构</h3>
<p>Docker Engine是一个包含以下组件的客户端一服务端（C/S）应用程序</p>
<ul>
<li>
<p>服务端---一个长时间运行的守护进程（Docker Daemon)</p>
</li>
<li>
<p>RESTAPI---一套用于与Docker Daemon通信并指示其执行操作的接口</p>
</li>
<li>
<p>客户端---命令行接口CLI(Command Linelnterface)</p>
<figure data-type="image" tabindex="2"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/Docker_R_C.png" alt="R-C" loading="lazy"></figure>
</li>
<li>
<p>CLI利用Docker命令通过REST API直接操控Docker Daemon执行操作</p>
</li>
<li>
<p>Docker Daemon负责创建并管理Docker的对象（镜像、容器、网络、数据卷）</p>
</li>
</ul>
<h4 id="docker结构">Docker结构</h4>
<figure data-type="image" tabindex="3"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230529205616866.png" alt="image-20230529205616866" loading="lazy"></figure>
<ul>
<li>
<p>Docker客户端(Docker Client)</p>
<p>Docker客户端(Docker Client）是用户与Docker进行交互的最主要方式。当在终端输入docke命令时，对应的就会在服务端产生对应的作用，并把结果返回给客户端。Docker Client除了连接本地服务端，通过更改或指定DOCKER_HOST连接远程服务端。</p>
</li>
<li>
<p>Docker服务端(DockerServer)</p>
<p>Docker Daemon其实就是Docker的服务端。它负责监听Docker API请求（如Docker Client)并管理Docker对象(Docker Objects)，如镜像、容器、网络、数据卷等</p>
</li>
<li>
<p>Docker Registries</p>
<ul>
<li>俗称Docke仓库，专门用于存储镜像的云服务环境．</li>
<li>Docker Hub就是一个公有的存放镜像的地方，类似Github存储代码文件。同样的也可以类似Github搭建私有的仓库。</li>
</ul>
</li>
<li>
<p>Docker对象(DockerObJects)</p>
<ul>
<li>镜像：一个Docker的可执行文件，其中包括运行应用程序所需的所有代码内容、依赖库、环境变量和配置文件等。</li>
<li>容器：镜像被运行起来后的实例。</li>
<li>网络：外部或者容器间如何互相访问的网络方式，如host模式、bridge模式。</li>
<li>数据卷：容器与宿主机之间、容器与容器之间共享存储方式，类似虚拟机与主机之间的共享文件目录。</li>
</ul>
</li>
</ul>
<h3 id="docker底层技术">Docker底层技术</h3>
<ul>
<li>
<p>Docker使用GO语言实现。</p>
</li>
<li>
<p>Docker利用用linux内核的几个特性来实现功能：</p>
<ul>
<li>利用linux的命名空间（Namespaces)：为Docke俗器提供操作系统层面的隔离。
<ul>
<li>进程号隔离：每一个容器内运行的第一个进程，进程号总是从1开始起算</li>
<li>网络隔离：容器的网络与宿主机或其他容器的网络是隔离的、分开的，也就是相当于两个网络</li>
<li>进程间通隔离：容器中的进程与宿主机或其他容器中的进程是互相不可见的，通信需要借助网络</li>
<li>文件系统挂载隔离：容器拥有自己单独的工作目录</li>
<li>内核以及系统版本号隔离：容器查看内核版本号或者系统版本号时，查看的是容器的，而非宿主机的</li>
</ul>
</li>
<li>利用linux控制组（Control Groups)：为Docker容器提供硬件层面的隔离。
<ul>
<li>控制组能控制应用程序所使用的硬件资源。</li>
<li>基于该性质，控制组帮助Docke引擎将硬件资源共享给容器使用，并目加以约束和限制。如控制容器所使用的内存大小。</li>
</ul>
</li>
<li>利用Linux的联合文件系统（Union File Systems)：利用分层(layer）思想管理境像和容器。</li>
</ul>
<p>这也就意味着Docker只能在linux上运行。</p>
<p>在Windows、MacOS上运行Docker，其实本质上是借助了虚拟化技术，然后在linux虚拟机上运行的Docke程序。</p>
</li>
<li>
<p>容器格式（Container Format）：</p>
<ul>
<li>Docker Engine将namespace、cgroups、UnionFS进行组合后的一个package，就是一个容器格式(Container Format)。Docker通过对这个package中的namespace、cgroups、UnionFS进管理控制实现容器的创建和生命周期管理。</li>
<li>容器格式(Container Format)有多种，其中Docker目前使用的容器格式被称为 <code>libcontainer</code>。</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python对象深入]]></title>
        <id>https://zxh-w.github.io/post/python-dui-xiang-shen-ru/</id>
        <link href="https://zxh-w.github.io/post/python-dui-xiang-shen-ru/">
        </link>
        <updated>2023-05-26T06:51:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="type-object和class的关系">type、object和class的关系</h2>
<figure data-type="image" tabindex="1"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230507082334065.png" alt="image-20230507082334065" loading="lazy"></figure>
<ul>
<li>type生成了所有的class</li>
<li>所有class都继承了object</li>
<li>object是顶层基类，它没有父类</li>
<li>type也是一个类，但同时它还是一个对象</li>
<li>函数和类也是对象，属于Python的一等公民</li>
</ul>
<h2 id="python魔法函数">Python魔法函数</h2>
<blockquote>
<p>Python的魔法函数是指Python的类中，一系列函数名由双下划线包裹的函数。在特定时刻(调用内置函数时)，Python会自动调用这些函数。魔法函数不是通过继承等机制获得的，而是类一旦定义，Python内部机制自动会给类赋予这些特殊的函数，且用户是不能创建魔法函数的，即使函数名以双下划线开头和双下划线结尾。通过魔法函数可以实现许多个性化、便捷的操作。</p>
</blockquote>
<blockquote>
<p><strong>Python中每个魔法函数都对应了一个Python内置函数或操作。</strong></p>
</blockquote>
<h3 id="非数学运算">非数学运算</h3>
<table>
<thead>
<tr>
<th>描述</th>
<th>函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串表示</td>
<td><code>__repr__</code>、<code>__str__</code></td>
</tr>
<tr>
<td>集合、序列相关</td>
<td><code>__len__</code>、<code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code>、<code>__contains__</code></td>
</tr>
<tr>
<td>迭代相关</td>
<td><code>__iter__</code>、<code>__next__</code></td>
</tr>
<tr>
<td>可调用</td>
<td><code>__call__</code></td>
</tr>
<tr>
<td><code>with</code>上下文管理器</td>
<td><code>__enter__</code>、<code>__exit__</code></td>
</tr>
<tr>
<td>数值转换</td>
<td><code>__abs__</code>、<code>__float__</code>、<code>__bool__</code>、<code>__int__</code>、<code>__hsah__</code>、<code>__index__</code></td>
</tr>
<tr>
<td>元类相关</td>
<td><code>__new__</code>、<code>__init__</code></td>
</tr>
<tr>
<td>属性相关</td>
<td><code>__getattr__</code>、<code>__setattr__</code>、<code>__getattribute__</code>、<code>__setattribute__</code>、<code>__dir__</code></td>
</tr>
<tr>
<td>属性描述符</td>
<td><code>__get__</code>、<code>__set__</code>、<code>__delete__</code></td>
</tr>
<tr>
<td>协程</td>
<td><code>__await__</code>、<code>__aiter__</code>、<code>__anext__</code>、<code>__aenter__</code>、<code>__aexit__</code></td>
</tr>
</tbody>
</table>
<h3 id="数学运算">数学运算</h3>
<table>
<thead>
<tr>
<th>描述</th>
<th>函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>一元运算符</td>
<td><code>__neg__（-）</code>、<code>__pos__（+）</code>、<code>__abs__</code></td>
</tr>
<tr>
<td>二元运算符</td>
<td><code>__lt__(&lt;)</code>、<code>__le__ &lt;=</code>、<code> __eq__ ==</code> 、<code>__ne__ !=</code>、<code>__gt__ &gt;</code>、<code> __ge__ &gt;=</code></td>
</tr>
<tr>
<td>算术运算符</td>
<td><code>__add__ + </code>、<code>__sub__ -</code>、<code>__mul__ *</code>、<code>__truediv__ /</code>、<code> __floordiv__ //</code> 、<code>__mod__ %</code>、<code> __divmod__ divmod()</code> 、<code> __pow__ ** 或 pow()</code> 、 <code>__round__ round()</code></td>
</tr>
<tr>
<td>反向算术运算符</td>
<td><code>__radd__ </code>、<code> __rsub__</code> 、<code>__rmul__</code>、<code> __rtruediv__</code> 、<code> __rfloordiv__</code> 、<code>__rmod__</code>、<code>__rdivmod__</code> 、<code> __rpow__</code></td>
</tr>
<tr>
<td>增量赋值算术运算符</td>
<td><code>__iadd__</code> 、 <code>__isub__ </code>、 <code>__imul__</code> 、 <code>__itruediv__ </code>、 <code>__ifloordiv__ </code>、 <code>__imod__</code> 、<code>__ipow__</code></td>
</tr>
<tr>
<td>位运算符</td>
<td><code>__invert__ ~ </code>、<code>__lshift__ &lt;&lt;</code>、<code>__rshift__ &gt;&gt;</code>、 <code>__and__ &amp; </code>、 <code>__or__ </code>、<code>__xor__ ^</code></td>
</tr>
<tr>
<td>反向位运算符</td>
<td><code>__rlshift__ &lt;&lt;</code>、<code>__rrshift__ &gt;&gt;</code>、 <code>__rand__ &amp; </code>、 <code>__ror__ </code>、<code>__rxor__ ^</code></td>
</tr>
<tr>
<td>增量赋值位运算符</td>
<td><code>__ilshift__ </code>、<code>__irshift__</code>、<code>__iand__</code>、<code> __ixor__</code> 、<code> __ior__</code></td>
</tr>
</tbody>
</table>
<h3 id="鸭子类型和多态">鸭子类型和多态</h3>
<pre><code class="language-python">'''
Cat、Dog、Duck都有相同的行为，say
'''
class Cat(object):
    def say(self):
        print('I am a cat')
class Dog(object):
    def say(self):
        print('I am a dog')
class Duck(object):
    def say(self):
        print('I am a duck')
animals = [Cat,Dog,Duck]
for animal in animalss:
    animal().say()
</code></pre>
<h3 id="抽象基类abc模块">抽象基类(abc模块)</h3>
<blockquote>
<ul>
<li>抽象基类不能实例化</li>
<li>子类需要实现基类指定的抽象方法</li>
</ul>
</blockquote>
<ul>
<li>
<p>某些情况下希望判定某个对象的类型：<code>isinstance</code></p>
</li>
<li>
<p>需要强制某个子类必须实现某些方法</p>
<blockquote>
<p>实现一个web框架，集成cache(redis，cache，memorycache)</p>
</blockquote>
<pre><code class="language-python">import abc
class CacheBase(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def get(self,key):
        pass
   	@abc.abstractmethod
    def set(self,key,value):
        pass
</code></pre>
</li>
</ul>
<h3 id="使用-isinstance而不是-type">使用 <code>isinstance</code>而不是 <code>type</code></h3>
<pre><code class="language-python">class A:
	pass
class B:
    pass
b = B()

print(isinstance(b,B)) #True
print(isinstance(b,A)) #True
print(type(b) is A) #False
</code></pre>
<h3 id="类变量和实例变量">类变量和实例变量</h3>
<pre><code class="language-python">class A:
    aa = 1 #类变量
    # 参数self是A的一个实例
    def __init__(self,x,y):
        self.x = x #实例变量 
        self.y = y #实例变量

a = A(2,3)
A.aa = 11 #修改的是类属性aa
a.aa = 100 # 会新建一个实例属性aa，并把aa的值设置为100
print(A.aa)#11
print(a.aa)#100
</code></pre>
<h3 id="类属性和实例属性以及查找顺序">类属性和实例属性以及查找顺序</h3>
<pre><code class="language-python">class A:
	name = 'A'
    def __init()__(self):
        self.name = 'obj'
a = A()
print(a.name)
</code></pre>
<blockquote>
<p>如果使用BFS，那么当C和D有同名方法时，D中的方法就会被覆盖，而我们可能是要D中的方法。</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230516102002292.png" alt="" loading="lazy"></figure>
<blockquote>
<p>深度优先算法不是很合理，因为如果按A-&gt;B-&gt;D-&gt;C的方式查询，C中的方法可能是继承重写D的，这样一来C中的方法就找不到了。</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230516101557360.png" alt="image-20230516101557360" loading="lazy"></figure>
<blockquote>
<p>综上，BFS与DFS均有不适用的情况，Python选择了C3算法。C3算法对第一张图片的查找顺序和DFS相同，对第二张图片的查找顺序和BFS形同。</p>
</blockquote>
<h3 id="类方法-静态方法和实例方法">类方法、静态方法和实例方法</h3>
<blockquote>
<p>实例方法只能被实例对象调用(Python3 中，如果类调用实例方法，需要显示的传self, 也就是实例对象自己)，静态方法(由<code>@staticmethod</code>装饰的方法)、类方法(由<code>@classmethod</code>装饰的方法)，可以被类或类的实例对象调用。</p>
</blockquote>
<ul>
<li>实例方法：第一个参数必须要默认传实例对象，一般习惯用<code>self</code>。</li>
<li>静态方法：参数没有要求。</li>
<li>类方法：第一个参数必须要默认传类，一般习惯用<code>cls</code>。</li>
</ul>
<h3 id="数据封装和私有属性">数据封装和私有属性</h3>
<pre><code class="language-python">class User:
    def __init__(self,age,weight):
        self.age = age
        self.__weight = weight#属性名前加__
    def get_age(self):
        return self.age
    def get_weight(self):
        return self.__weight
if __name__ == '__main__':
    user = User(32,64)
    print(user.age) # 32
    print(user.__weight) #报错
    print(user.get_weight()) # 64
    print(user._User__wieght) # 64
</code></pre>
<h3 id="python对象的自省机制">Python对象的自省机制</h3>
<blockquote>
<p>自省是通过一定的机制查询到对象的内部结构。检查某些事物以确定它是什么、它知道什么以及它能做什么。</p>
</blockquote>
<p>Python中比较常见的自省（<code>introspection</code>）机制(函数用法)有： <code>dir()</code>，<code>type()</code>,<code> hasattr()</code>,<code> isinstance()</code>，通过这些函数，我们能够在程序运行时得知对象的类型，判断对象是否存在某个属性，访问对象的属性。</p>
<h3 id="super函数调用"><code>super()</code>函数调用</h3>
<pre><code class="language-python">class A:
    def __init__(self):
        print('A')
class B(A):
    def __init__(self):
        print('B')
        super().__init__()
class C(A):
    def __init__(self):
        print('C')
        super().__init__()
class D(B,C):
     def __init__(self):
        print('D')
        super().__init__()
d = D()
print(D.__mro__)

super(C,d).__init__()# A
</code></pre>
<p><code>super</code>的作用是 <strong>返回的是<code>obj</code>的MRO中<code>class</code>类的父类</strong>,在这里就表示<strong>返回的是<code>d</code>的MRO中<code>C</code>类的父类</strong>。</p>
<h3 id="mixin功能">Mixin功能</h3>
<p>Mixin 即 <code>Mix-in</code>，常被译为“混入”，是一种编程模式，这些类采用统一的命名规范（例如Mixin后缀），以此标识这些类只是用来混合功能的。</p>
<ul>
<li>Mixin类功能单一（一个Mixin类往往只实现一个功能（函数））</li>
<li>如果有多个功能，那就写多个Mixin类</li>
<li>不要和基类关联，可以和任意基类组合</li>
<li>在Mixin类中，不要使用super()这种用法，Mixin类只用于拓展子类的功能，不能影响子类的主要功能，子类也不能依赖 Mixin类</li>
</ul>
<h3 id="python中上下文管理器">Python中上下文管理器</h3>
<pre><code class="language-python">def exec_try():
    try:
        print('---------codeing  start----------')
        raise KeyError
        return 1
    except KeyError as e:
        print('---------Key Error-----------')
        return 2
    else:
        print('---------Others--------------')
        return 3
    finally:
        print('-----------final-------------')
        return 4

res = exec_try()
print(res)
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://zxh-w.oss-cn-beijing.aliyuncs.com/img/image-20230517105332343.png" alt="image-20230517105332343" loading="lazy"></figure>
<blockquote>
<p>当一个类实现了 <code>__enter__()</code>和 <code>__exit__()</code>魔法函数时，那么这个类就实现了上下文管理器协议，<code>with</code>语句就可以直接使用这个类。</p>
</blockquote>
<pre><code class="language-python">with context_expression [as target(s)]:
    with-body
</code></pre>
<p>一个类在 Python 中，只要实现以下方法，就实现了[上下文管理器协议]：</p>
<ul>
<li><code>__enter__</code>：在进入 <code>with</code> 语法块之前调用，返回值会赋值给 <code>with</code> 的 <code>target</code></li>
<li><code>__exit__</code>：在退出 <code>with</code> 语法块时调用，一般用作异常处理</li>
</ul>
<h3 id="自定义序列">自定义序列</h3>
<pre><code class="language-python">import numbers
class Question():
    def __init__(self,name,num,answer):
        self.name = name
        self.num = num
        self.answer = answer
    
    def __getitem__(self,item):
        cls = type(self)
        
        if isinstance(item,slice):
            return cls(self.name,self.num,self.answer[item])
        elif isinstance(item,numbers.Integral):
            return cls(self.name,self.num,[self.answer[item],])
        
    def __revers__(self):
        self.answer.reverse()
        
q = Question('test',4,['a','b','c','d'])
print(q[::2])
</code></pre>
<h3 id="属性描述符和属性查找过程">属性描述符和属性查找过程</h3>
<p>如果<code>user</code>是某个类的实例，那么<code>user.age</code>以及等价的<code>getattr(user,'age'))</code>首先调用 <code>__getattribute__</code>。如果类定义了 <code>__getattr__</code>方法，那么在 <code>__getattribute__</code>抛出 <code>AttributrError</code>的时候就会调用到 <code>__getattr__</code>，而对于描述符（<code>__get__</code>）的调用，则是发生在 <code>__getattribute__</code>内部的。</p>
<p>user = User()，那么user.age查找顺序如下：</p>
<ol>
<li>如果age是出现在User或其基类的 <code>__dict__</code>中，且<code>age</code>是<code>data descriptor</code> ,那么调用其 <code>get</code>方法</li>
<li>如果 <code>age</code>出现在 user的 <code>__dict__</code>中，那么直接返回 <code>obj.__dict__['age']</code></li>
<li>如果age是出现在User或其基类的 <code>__dict__</code>中，
<ol>
<li>如果 <code>age</code>是 <code>non-data descriptor</code> ,那么调用其 <code>__get__</code>方法，否则</li>
<li>返回 <code>__dict__['age']</code></li>
</ol>
</li>
<li>如果User有 <code>__getattr__</code>方法，调用 <code>__getattr__</code>方法</li>
<li>抛出 <code>AttributeError</code></li>
</ol>
<h3 id="__new__-和-__init__的区别"><code>__new__</code> 和 <code>__init__</code>的区别</h3>
<ul>
<li><code>__new__</code>是用来控制对象的生成过程， <code>__init__</code>是用来完善对象的</li>
<li>如果 <code>__new__</code>方法不返回对象，则不会调用 <code>__init__</code>函数</li>
</ul>
]]></content>
    </entry>
</feed>